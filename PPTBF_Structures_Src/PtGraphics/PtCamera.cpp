/*
 * Publication: Semi-Procedural Textures Using Point Process Texture Basis Functions
 * Authors: anonymous
 *
 * Code author: Pascal Guehl
 *
 * anonymous
 * anonymous
 */

/** 
 * @version 1.0
 */

#include "PtCamera.h"

/******************************************************************************
 ******************************* INCLUDE SECTION ******************************
 ******************************************************************************/

// GL
#include <glad/glad.h>

// STL
#include <iostream>

// glm
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/rotate_vector.hpp>

/******************************************************************************
 ****************************** NAMESPACE SECTION *****************************
 ******************************************************************************/

// Project
using namespace PtGraphics;

// STL
using namespace std;

/******************************************************************************
 ************************* DEFINE AND CONSTANT SECTION ************************
 ******************************************************************************/

/******************************************************************************
 ***************************** TYPE DEFINITION ********************************
 ******************************************************************************/

/******************************************************************************
 ***************************** METHOD DEFINITION ******************************
 ******************************************************************************/

// Example
// https://gitlab.com/pteam/korvins-qtbase/blob/6f7bc2a7074b7f8c9dacd997d4af597396bbc8d0/examples/opengl/qopenglwindow/main.cpp

// Explanations
// https://blog.qt.io/blog/2014/11/20/qt-weekly-20-completing-the-offering-qopenglwindow-and-qrasterwindow/

/******************************************************************************
 * Default constructor
 ******************************************************************************/
PtCamera::PtCamera()
{
	mEye = glm::vec3( 0.f, 0.f, 1.f );
	mFront = glm::vec3( 0.f, 0.f, -1.f );
	mUp = glm::vec3( 0.f, 1.f, 0.f );

	mFovY = 45.f;
	mAspect = 1.f;
		
	mLeft = -1.f;
	mRight = 1.f;
	mBottom = -1.f;
	mTop = 1.f;

	mZNear = 0.1f;
	mZFar = 100.f;
	
	mSensitivity = 0.1f;

	mCameraType = ePerspective;
}

/******************************************************************************
 * Destructor
 ******************************************************************************/
PtCamera::~PtCamera()
{
}

/******************************************************************************
 * Tilt
 ******************************************************************************/
void PtCamera::tilt( float pValue )
{
	const glm::vec3 right = glm::normalize( glm::cross( mFront, mUp ) );
	mFront = glm::rotate( mFront, pValue, right );
}

/******************************************************************************
 * Pan (i.e. yaw)
 ******************************************************************************/
void PtCamera::pan( float pValue )
{
	mFront = glm::rotate( mFront, pValue, mUp );
}

/******************************************************************************
 * Dolly
 ******************************************************************************/
void PtCamera::dolly( float pValue )
{
	mEye += mSensitivity * pValue * mFront;
}

/******************************************************************************
 * Truck
 ******************************************************************************/
void PtCamera::truck( float pValue )
{
	mEye += glm::normalize( glm::cross( mFront, mUp ) ) * pValue * mSensitivity;
}

/******************************************************************************
 * Pedestal
 ******************************************************************************/
void PtCamera::pedestal( float pValue )
{
	mEye += pValue * mSensitivity * mUp;
}

/******************************************************************************
 * Zoom
 ******************************************************************************/
void PtCamera::zoom( float pValue )
{
	const float cMaxFovY = 120.f;
	if ( mFovY >= 1.f && mFovY <= cMaxFovY )
	{
		mFovY += mSensitivity * pValue;
	}

	if ( mFovY <= 1.f )
	{
		mFovY = 1.f;
	}
	
	if ( mFovY >= cMaxFovY )
	{
		mFovY = cMaxFovY;
	}
}

/******************************************************************************
 * ...
 ******************************************************************************/
void PtCamera::setEye( const glm::vec3& pPosition )
{
	mEye = pPosition;
}

/******************************************************************************
 * ...
 ******************************************************************************/
void PtCamera::setFront( const glm::vec3& pPosition )
{
	mFront = pPosition;
}

/******************************************************************************
 * ...
 ******************************************************************************/
void PtCamera::setUp( const glm::vec3& pDirection )
{
	mUp = pDirection;
}

/******************************************************************************
 * ...
 ******************************************************************************/
float PtCamera::getFovY() const
{
	return mFovY;
}

/******************************************************************************
 * ...
 ******************************************************************************/
void PtCamera::setFovY( float pValue )
{
	mFovY = pValue;
}

/******************************************************************************
 * ...
 ******************************************************************************/
float PtCamera::getAspect() const
{
	return mAspect;
}

/******************************************************************************
 * ...
 ******************************************************************************/
void PtCamera::setAspect( float pValue )
{
	mAspect = pValue;
}

/******************************************************************************
 * ...
 ******************************************************************************/
float PtCamera::getLeft() const
{
	return mLeft;
}

/******************************************************************************
 * ...
 ******************************************************************************/
void PtCamera::setLeft( float pValue )
{
	mLeft = pValue;
}

/******************************************************************************
 * ...
 ******************************************************************************/
float PtCamera::getRight() const
{
	return mRight;
}

/******************************************************************************
 * ...
 ******************************************************************************/
void PtCamera::setRight( float pValue )
{
	mRight = pValue;
}

/******************************************************************************
 * ...
 ******************************************************************************/
float PtCamera::getBottom() const
{
	return mBottom;
}

/******************************************************************************
 * ...
 ******************************************************************************/
void PtCamera::setBottom( float pValue )
{
	mBottom = pValue;
}

/******************************************************************************
 * ...
 ******************************************************************************/
float PtCamera::getTop() const
{
	return mTop;
}

/******************************************************************************
 * ...
 ******************************************************************************/
void PtCamera::setTop( float pValue )
{
	mTop = pValue;
}

/******************************************************************************
 * ...
 ******************************************************************************/
float PtCamera::getZNear() const
{
	return mZNear;
}

/******************************************************************************
 * ...
 ******************************************************************************/
void PtCamera::setZNear( float pValue )
{
	mZNear = pValue;
}

/******************************************************************************
 * ...
 ******************************************************************************/
float PtCamera::getZFar() const
{
	return mZFar;
}

/******************************************************************************
 * ...
 ******************************************************************************/
void PtCamera::setZFar( float pValue )
{
	mZFar = pValue;
}

/******************************************************************************
 * ...
 ******************************************************************************/
float PtCamera::getSensitivity() const
{
	return mSensitivity;
}

/******************************************************************************
 * ...
 ******************************************************************************/
void PtCamera::setSensitivity( float pValue )
{
	mSensitivity = pValue;
}

/******************************************************************************
 * ...
 ******************************************************************************/
glm::mat4 PtCamera::getViewMatrix() const
{
	return glm::lookAt( mEye, mEye + mFront, mUp );
}

/******************************************************************************
 * ...
 ******************************************************************************/
glm::mat4 PtCamera::getProjectionMatrix() const
{
	if ( mCameraType == eOrthographic )
	{
		return glm::ortho( mLeft, mRight, mBottom, mTop );
	}
	
	return glm::perspective( mFovY, mAspect, mZNear, mZFar );
}

/******************************************************************************
 * ...
 ******************************************************************************/
void PtCamera::setCameraType( ECameraType pType )
{
	mCameraType = pType;
}
